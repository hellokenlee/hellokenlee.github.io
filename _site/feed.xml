<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HelloKenLee-Blog</title>
    <description>Abstractness is the price of genarality.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Mar 2017 20:01:15 +0800</pubDate>
    <lastBuildDate>Thu, 09 Mar 2017 20:01:15 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Leetcode 297 Serialize and Deserialize Binary Tree 解题报告</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#题目信息&quot; id=&quot;markdown-toc-题目信息&quot;&gt;题目信息&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#题目-297-serialize-and-deserialize-binary-tree&quot; id=&quot;markdown-toc-题目-297-serialize-and-deserialize-binary-tree&quot;&gt;题目： &lt;a href=&quot;https://leetcode.com/problems/serialize-and-deserialize-binary-tree/?tab=Description&quot;&gt;297. Serialize and Deserialize Binary Tree&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#难度-hard&quot; id=&quot;markdown-toc-难度-hard&quot;&gt;难度： Hard&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#正确率-322&quot; id=&quot;markdown-toc-正确率-322&quot;&gt;正确率： 32.2%&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#问题描述&quot; id=&quot;markdown-toc-问题描述&quot;&gt;问题描述:&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#相关题目449-serialize-and-deserialize-bst&quot; id=&quot;markdown-toc-相关题目449-serialize-and-deserialize-bst&quot;&gt;相关题目：&lt;a href=&quot;https://leetcode.com/problems/serialize-and-deserialize-bst&quot;&gt;449. Serialize and Deserialize BST&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#问题分析&quot; id=&quot;markdown-toc-问题分析&quot;&gt;问题分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#解题思路&quot; id=&quot;markdown-toc-解题思路&quot;&gt;解题思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#结果分析&quot; id=&quot;markdown-toc-结果分析&quot;&gt;结果分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#主要数据结构和方法&quot; id=&quot;markdown-toc-主要数据结构和方法&quot;&gt;主要数据结构和方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#源代码&quot; id=&quot;markdown-toc-源代码&quot;&gt;源代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;题目信息&quot;&gt;题目信息&lt;/h3&gt;

&lt;h5 id=&quot;题目-297-serialize-and-deserialize-binary-tree&quot;&gt;题目： &lt;a href=&quot;https://leetcode.com/problems/serialize-and-deserialize-binary-tree/?tab=Description&quot;&gt;297. Serialize and Deserialize Binary Tree&lt;/a&gt;&lt;/h5&gt;

&lt;h5 id=&quot;难度-hard&quot;&gt;难度： Hard&lt;/h5&gt;

&lt;h5 id=&quot;正确率-322&quot;&gt;正确率： 32.2%&lt;/h5&gt;

&lt;h5 id=&quot;问题描述&quot;&gt;问题描述:&lt;/h5&gt;

&lt;p&gt;Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.&lt;/p&gt;

&lt;p&gt;Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.&lt;/p&gt;

&lt;p&gt;For example, you may serialize the following tree&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1
   / \
  2   3
     / \
    4   5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.&lt;/p&gt;

&lt;h5 id=&quot;相关题目449-serialize-and-deserialize-bst&quot;&gt;相关题目：&lt;a href=&quot;https://leetcode.com/problems/serialize-and-deserialize-bst&quot;&gt;449. Serialize and Deserialize BST&lt;/a&gt;&lt;/h5&gt;

&lt;h3 id=&quot;问题分析&quot;&gt;问题分析&lt;/h3&gt;
&lt;p&gt;　　问题的大意是说对于一棵普通的二叉树，如何把它序列化成一个字符串，而对于已经序列化后的二叉树字符串，如何反序列化回一个二叉树。要求是尽可能的少占用空间而且要求序列化后的二叉树一定能反序列化回去，结构和数据都不能够丢失。&lt;/p&gt;

&lt;h3 id=&quot;解题思路&quot;&gt;解题思路&lt;/h3&gt;
&lt;p&gt;　　这个问题的求解思路无非两点：1. 如何把二叉树型结构转成线性结构？ 2. 如何把节点值转成字符串？&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;如何把二叉树型结构转成线性结构：&lt;/strong&gt; 这让我想起了很久以前在SOJ上做的一个问题，就是说要把一个二叉树还原，必须要有其中序遍历结果+前序或后序其中一种结果。不过事实上，对于一颗二叉树的任何一个非空节点，我们存储他的所有左右儿子的值，不管其儿子是否为空，这样我们只需要前序遍历的结果就能还原一个二叉树。或者我们把先序遍历叫做BFS或者层次遍历更为准确。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;如何把节点值转成字符串：&lt;/strong&gt; 因为题目给出的二叉树其数据为int，因此一个很普通的思路就是直接把他转成字符串。比如，把&lt;code class=&quot;highlighter-rouge&quot;&gt;1234&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;1234&quot;&lt;/code&gt;， 把&lt;code class=&quot;highlighter-rouge&quot;&gt;-256&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;-256&quot;&lt;/code&gt;。这样子做的好处是序列化后的二叉树有一定的可读性。c++11后也提供了相应的转化函数比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;stoi()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;itos()&lt;/code&gt;。然而这真的是比较优化的解决方法吗? 从时间上来说，这样子转化要做常数时间的乘法和加法；从空间上来说，这样子存储的长度取决于整数的长短，最长是&lt;code class=&quot;highlighter-rouge&quot;&gt;INT_MIN&lt;/code&gt;，占11位；从复杂度的来说，这种处理方法除了处理数字以外，还需要约定分割符，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;等等。&lt;br /&gt;
　　要插入分隔符的原因是我们存的数据是不定长的，假设我们采用定长的方式存储，我们就无需插入分割符。因为长度就是天然的分隔符。一个比较优化的解决方法是，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;占4个byte，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;占1个byte，因此我们可以直接用4个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;来表示一个int。但是，我们还要区分该节点是不是空节点，因此我们需要多一个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;来存储。那么对于一个二叉树节点，我们把其序列化为5个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;　　一个比较好用的技巧是，对于一个节点的&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;值，我们用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;char*&lt;/code&gt;指针来先后访问其0,1,2,3位，相当于把一个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;分成4个8位的二进制数，并把该二进制数对于的ascii码字符存入结果字符串(尽管单个字符没实际意义)。同样的，对于一个字符串，我们每5位，每5位处理，用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;int*&lt;/code&gt;指针来访问，就能直接完成转换，而不用增加额外的函数。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解决指针对齐问题：&lt;/strong&gt; 上面的解决方法看上去很美好，但是事实上我们因为需要5个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;才能表示一个二叉树节点，因此在某些环境上可能会报指针未对齐的运行时错误(比如Leetcode的辣鸡环境)。也很有道理，毕竟我们产生出来的字符串长度是5N个byte，而使用&lt;code class=&quot;highlighter-rouge&quot;&gt;int*&lt;/code&gt;访问最好是4N个byte长度。关于这个问题，我想出了三个解决方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;手写转换函数，也就是对于表示一个节点的5个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;，我们通位运算&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;来转成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;。因为是位运算，因此在时间上也很快。&lt;/li&gt;
  &lt;li&gt;使用缓存。把5个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;中的后四位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;的值通过&lt;code class=&quot;highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt;函数拷贝到缓存&lt;code class=&quot;highlighter-rouge&quot;&gt;char buffer[4]&lt;/code&gt;中，这样在&lt;code class=&quot;highlighter-rouge&quot;&gt;buffer&lt;/code&gt;中就是4byte对齐的，可以直接通过int访问。&lt;/li&gt;
  &lt;li&gt;新建一个结构体比如下，包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;和一个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;。结构体的长度为5byte，然后我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;node* a&lt;/code&gt;访问，&lt;code class=&quot;highlighter-rouge&quot;&gt;a-&amp;gt;val&lt;/code&gt;来取值。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　后面的实现采用第二种方法，因为写起来最短。&lt;/p&gt;

&lt;h3 id=&quot;结果分析&quot;&gt;结果分析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;时间复杂度： O(N)，时间复杂度就是进行广度优先搜索的时间，N为二叉树的节点数。&lt;/li&gt;
  &lt;li&gt;空间复杂度： O(N)，采用队列来进行广度优先搜索，其最坏情况下是队列中存有所有节点的指针，复杂的为O(N)。还有就是序列化后的字符串长度，很明显，其长度为5N，也就是O(N)，其余空间使用均为常数。因此总的复杂的为O(N)。&lt;/li&gt;
  &lt;li&gt;通过时间： 22ms&lt;/li&gt;
  &lt;li&gt;排名： Beats 99.79% submissions. (截止至提交时间)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;主要数据结构和方法&quot;&gt;主要数据结构和方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct TreeNode&lt;/code&gt;： 二叉树数据结构&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string serialize(TreeNode* root)&lt;/code&gt;： 把二叉树转换成字符串函数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeNode* deserialize(string data)&lt;/code&gt;： 把一个字符串转换成二叉树，返回根节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;queue&amp;lt;TreeNode*&amp;gt; que&lt;/code&gt;： 用于做先序遍历的队列&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeNode* processNode(unsigned char* &amp;amp;cptr,queue&amp;lt;TreeNode*&amp;gt; &amp;amp;que)&lt;/code&gt;： 把字符串中的5个byte数据转化成一个二叉树节点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;源代码&quot;&gt;源代码&lt;/h3&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Codec&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Encodes a tree to a single string.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//BFS队列
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//根节点压入队列
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//BFS
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//儿子节点压入队列
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//序列化该节点
&lt;/span&gt;                &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//序列化NULL
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Decodes your encoded data to tree.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deserialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//处理根节点
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//处理剩下的节点
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;processNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;que&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 05 Mar 2017 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/05/leetcode-297/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/05/leetcode-297/</guid>
        
        <category>算法</category>
        
        <category>Leetcode</category>
        
        
        <category>算法课解题报告</category>
        
      </item>
    
      <item>
        <title>Leetcode 33 Search in Rotated Sorted Array 解题报告</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#题目信息&quot; id=&quot;markdown-toc-题目信息&quot;&gt;题目信息&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#题目-33-search-in-rotated-sorted-array&quot; id=&quot;markdown-toc-题目-33-search-in-rotated-sorted-array&quot;&gt;题目： &lt;a href=&quot;https://leetcode.com/problems/search-in-rotated-sorted-array/&quot;&gt;33. Search in Rotated Sorted Array&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#难度-medium&quot; id=&quot;markdown-toc-难度-medium&quot;&gt;难度： Medium&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#正确率-3208&quot; id=&quot;markdown-toc-正确率-3208&quot;&gt;正确率： 32.08%&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#问题描述&quot; id=&quot;markdown-toc-问题描述&quot;&gt;问题描述:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#问题分析&quot; id=&quot;markdown-toc-问题分析&quot;&gt;问题分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#解题思路&quot; id=&quot;markdown-toc-解题思路&quot;&gt;解题思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#主要数据结构&quot; id=&quot;markdown-toc-主要数据结构&quot;&gt;主要数据结构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#源代码&quot; id=&quot;markdown-toc-源代码&quot;&gt;源代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;题目信息&quot;&gt;题目信息&lt;/h3&gt;

&lt;h4 id=&quot;题目-33-search-in-rotated-sorted-array&quot;&gt;题目： &lt;a href=&quot;https://leetcode.com/problems/search-in-rotated-sorted-array/&quot;&gt;33. Search in Rotated Sorted Array&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;难度-medium&quot;&gt;难度： Medium&lt;/h4&gt;

&lt;h4 id=&quot;正确率-3208&quot;&gt;正确率： 32.08%&lt;/h4&gt;

&lt;h4 id=&quot;问题描述&quot;&gt;问题描述:&lt;/h4&gt;

&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br /&gt;
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).&lt;br /&gt;
You are given a target value to search. If found in the array return its index, otherwise return -1. &lt;br /&gt;
You may assume no duplicate exists in the array.&lt;/p&gt;

&lt;h3 id=&quot;问题分析&quot;&gt;问题分析&lt;/h3&gt;
&lt;p&gt;　　问题的大意是说，把一个升序的数组以某一个数为中心”旋转”以后得到一个数组，在这个数组中查找一个数，如果能查找到，就返回它的下标，如果不能查找到，就返回-1。
　　一开始我没怎么理解这个“旋转”的含义，其实就是说，选定一个数，然后把整一个数组循环左移(右移也行)到这个数作为第一个，把左移溢出的数放在数组右边。
　　比如[0,1,2,4,5,6,7]，假设我们选择的数是4,那么“旋转的”过程如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	-&amp;gt;[1,2,4,5,6,7,0] //把0循环左移，补到最右边
	-&amp;gt;[2,4,5,6,7,0,1] //把1循环左移，补到0的右边
	-&amp;gt;[4,5,6,7,0,1,2] //把2循环左移，补到1的右边,这时候4是第一位，结束。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;解题思路&lt;/h3&gt;
&lt;p&gt;　　首先这是一个查找问题，最简单的思路当然是扫一次出结果，时间复杂度为O(N)。我们且不提想要sort()一次再二分的那些自寻烦恼的思路(XD)。但是这种朴素的解法完全没有利用到题目给的信息，因为对于一个完全没有序的数组，我们也能扫一次出结果。因此这种解法肯定是TLE的。&lt;/p&gt;

&lt;p&gt;　　那么我们再观察一下样例数据，本身数组是有序的，经过了“旋转”之后尽管不是全局有序，但是起码是部分有序的，比如说第0位到第4位[4,5,6,7]是有序的，第5位到最后[0,1,2]也是有序的。那么一个简单的改进就是我扫前半部分[4,5,6,7]，如果找到了，返回，如果没找到，则我知道后面的[0,1,2]也是有序的了，然后在后面的数据中采用二分查找。然而，这种解法尽管在最好的情况下是O(lgN)，在平均和最坏的复杂度都是O(N)，如无意外也是TLE的。&lt;/p&gt;

&lt;p&gt;　　上述的想法其实相当于把原数组分成了两部分[A,B]，我们在A中使用扫描，在B中使用二分。那么能不能在A中也使用二分呢？因为原升序的数列可以写成[B,A]，现在我们要进行查找的数列是[A,B]，我们可以知道，B中的每一个数都比A小。 更确切来说，&lt;strong&gt;B中的每一个数都比A[0]小，A中的每一个元素都比A[0]大！&lt;/strong&gt; 有了这个条件，如果我们要找一个数X，如果X小于A[0],我们就应该在B中进行二分查找，若大于A[0]，我们则应该在A中进行查找。那么现在剩下的问题是，我们无法以常数时间区分A和B，因此，我们应该直接在整个数组中进行二分查找。和平时二分查找不同的是，假设我们要找的目标在A中，我们的mid命中了B中的数，我们应该把命中的数当作无限大处理；反之，如果我们命中了A的数，我们应该把它当作无限小来处理。举个例子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	nums=[4,5,6,7,0,1,2];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　如果我们要查找的数比nums[0]=4小(比如1)，我们相当于在&lt;code class=&quot;highlighter-rouge&quot;&gt;[-oo,-oo,-oo,-oo,0,1,2]&lt;/code&gt;中查找；反正，如果我们要找的数比nums[0]=4大(比如6)，我们相当于在&lt;code class=&quot;highlighter-rouge&quot;&gt;[4,5,6,7,+oo,+oo,+oo]&lt;/code&gt;中进行查找。
　　分析：二分查找每一次选取一个mid来和target进行比较，每次名字比较一次，总体时间复杂度为O(log2(N))；上述的二分查找除了需要和target比较以外，还需要和A[0]比较，因此最坏比较次数3次，时间复杂为O(3log2(N))，也就是O(lgN)。
　　这应该是比较优化的做法了，提交代码，最终通过时间为3ms，比80%的提交者优秀且和最佳成绩相差不足1ms，姑且认为是服务器状态差异。&lt;/p&gt;
&lt;h3 id=&quot;主要数据结构&quot;&gt;主要数据结构&lt;/h3&gt;
&lt;p&gt;　　- &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&amp;lt;int&amp;gt; nums&lt;/code&gt;：输入数组
　　- &lt;code class=&quot;highlighter-rouge&quot;&gt;int target&lt;/code&gt;：需要查找的目标
　　- &lt;code class=&quot;highlighter-rouge&quot;&gt;int left&lt;/code&gt;：二分查找左边界下标
　　- &lt;code class=&quot;highlighter-rouge&quot;&gt;int right&lt;/code&gt;：二分查找右边界下标
　　- &lt;code class=&quot;highlighter-rouge&quot;&gt;int midNum&lt;/code&gt;：二分查找的中间元素的值&lt;/p&gt;
&lt;h3 id=&quot;源代码&quot;&gt;源代码&lt;/h3&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;midNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//要找的数比nums[0]小(比如上面的2)但是nums[mid]又比nums[0]大，比如上面的7，那我们把midNum看做-oo
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;midNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INT_MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//要找的数比nums[0]大，但是nums[mid]又比nums[0]小，那我们把midNum看做+oo
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;midNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;midNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;midNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 26 Feb 2017 12:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/26/leetcode-33/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/26/leetcode-33/</guid>
        
        <category>算法</category>
        
        <category>Leetcode</category>
        
        
        <category>算法课解题报告</category>
        
      </item>
    
      <item>
        <title>OpenGL中真正的深度值——z-buffer探究</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#推导过程&quot; id=&quot;markdown-toc-推导过程&quot;&gt;推导过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#验证&quot; id=&quot;markdown-toc-验证&quot;&gt;验证&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;原创文章，未经作者(ken_4000@qq.com)授权，禁止转载。违者视为侵权，保留追究其法律责任的权利。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;  正如&lt;a href=&quot;https://learnopengl.com/#!Advanced-OpenGL/Depth-testing&quot;&gt;LearnOpenGL-高级OpenGL-深度测试&lt;/a&gt;中所述，在OpenGL的深度值可以通过在fragment shader中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;gl_FragCoord.z&lt;/code&gt;获得，其值域为[0,1]。但是物体离我们眼睛(摄像机)的真正距离是多少呢？怎么通过OpenGL中的深度反求“真正的深度”呢？&lt;/p&gt;

&lt;h3 id=&quot;推导过程&quot;&gt;推导过程&lt;/h3&gt;

&lt;p&gt;  我们假设在FragmentShader出来的的深度值为$ z_b $ =&lt;code class=&quot;highlighter-rouge&quot;&gt;gl_FragCoord.z&lt;/code&gt;，因为$ z_b $是值域为[0,1]，我们首先得转换回NDC坐标系下，假设NDC坐标系下的深度值为$ z_n $，OpenGL是这样转换的：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_b=0.5z_n+0.5&lt;/script&gt;

&lt;p&gt;  这时$ z_n $的值域为[-1,1]。 
  我们设视角坐标下的深度值为$z_r$(也就是实际的深度值，aka.物体到我们眼睛的距离, r for real)，同时我们假设视角截面体的近平面距离=near，远平面距离=far，OpenGL是这样转换的:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_b=\frac{1/z_r-1/near}{1/far-1/near}&lt;/script&gt;

&lt;p&gt;  上面公式反求$ z_r $，下面令$ f=far,n=near $：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_b=\frac{\frac{nf}{z_r}-f}{n-f}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_b(n-f)=\frac{nf}{z_r}-f&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{nf}{z_r}=z_b(n-f)+f&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_r=\frac{nf}{z_b(n-f)+f}&lt;/script&gt;

&lt;p&gt;  把$z_b$带入：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_r=\frac{nf}{0.5(z_n+1)(n-f)+f}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_r=\frac{2nf}{(z_n+1)(n-f)+2f}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_r=\frac{2nf}{f+n+z_n(n-f)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_r=\frac{2nf}{f+n-z_n(f-n)}&lt;/script&gt;

&lt;p&gt;  这就是网站上&lt;a href=&quot;https://learnopengl.com/#!Advanced-OpenGL/Depth-testing&quot;&gt;LearnOpenGL-高级OpenGL-深度测试&lt;/a&gt;给的公式的由来。但是很明显，网站上给的公式有错误，或者说该网站上面的表述不清楚。（后来作者评论区补充说明了）作者说希望转换到线性的z写入到颜色中显示距离，然而作者给出的Shader代码：&lt;/p&gt;
&lt;div class=&quot;language-glsl highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#version 330 core
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
  
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LinearizeDepth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Back to NDC 
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;far&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;far&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;	
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;             
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinearizeDepth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;gl_FragCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// divide by far for demonstration
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;vec3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;  函数&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearizeDepth(float depth) &lt;/code&gt;仅仅求出了$z_r$的值，从下面的验证可以看出$z_r\in[n,f]$，所以即使最后除了$far$之后$depth也是\in[n/f,1]$，而并非作者上面说的线性深度。
  要求线性深度，应该使用公式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F_{depth}=\frac{z-n}{f-n}&lt;/script&gt;

&lt;p&gt;  代码改为：&lt;/p&gt;
&lt;div class=&quot;language-glsl highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LinearizeDepth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;gl_FragCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;far&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;near&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//非线性转线性
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;p&gt;  因为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_n\in[-1,1]&lt;/script&gt;

&lt;p&gt;  所以分母(注意$f&amp;gt;n$)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{f+n-z_n(f-n)}\in[2f,2n]&lt;/script&gt;

&lt;p&gt;  所以&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z_r\in[n,f]&lt;/script&gt;

&lt;p&gt;  你问我深度值$z_r &amp;lt; near$的怎么办？$z_r &amp;lt; near$也就是不在视锥体内的值，早在光栅化之前给剔除了，根本不会传到fragment shader。对于$z_r &amp;gt; far$的值亦然。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://learnopengl.com/#!Advanced-OpenGL/Depth-testing&quot;&gt;https://learnopengl.com/#!Advanced-OpenGL/Depth-testing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real&quot;&gt;http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer&quot;&gt;http://stackoverflow.com/questions/6652253/getting-the-true-z-value-from-the-depth-buffer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 24 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/24/opengl-z-buffer/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/24/opengl-z-buffer/</guid>
        
        <category>数学</category>
        
        <category>图形学</category>
        
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>OpenGL: 摄像机类的设计(摄像机旋转的公式推导)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#前言&quot; id=&quot;markdown-toc-前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#问题描述&quot; id=&quot;markdown-toc-问题描述&quot;&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#思考过程&quot; id=&quot;markdown-toc-思考过程&quot;&gt;&lt;strong&gt;思考过程&lt;/strong&gt;&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#欧拉角&quot; id=&quot;markdown-toc-欧拉角&quot;&gt;&lt;strong&gt;欧拉角:&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#小学数学&quot; id=&quot;markdown-toc-小学数学&quot;&gt;&lt;strong&gt;小学数学：&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#二维映射三维&quot; id=&quot;markdown-toc-二维映射三维&quot;&gt;&lt;strong&gt;二维映射三维：&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  前一段时间在follow &lt;a href=&quot;&quot;&gt;LearOpenGL&lt;/a&gt; 学习OpenGL的核心模式，主要是学习GLSL和与GLSL配套的OpenGL。当我看到 &lt;a href=&quot;http://www.learnopengl.com/#!Getting-started/Camera&quot;&gt;Camera&lt;/a&gt; 这一章的时候，他在说明摄像机旋转的时候有说得不是很清楚(从原PO的下面评论区一堆人发问可以看出来)。其实原理是很简单的高中数学问题，在这和大家分享一下自己的思考过程。(原教程还是非常棒的，不想看原PO英文的同学推荐看中文版的教程&lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/&quot;&gt;LearnOpenGL-CN&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/question1.png&quot; alt=&quot;pic&quot; /&gt;
&lt;img src=&quot;/images/question2.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(下面的评论区很多人对这点发问)&lt;/p&gt;

&lt;h3 id=&quot;问题描述&quot;&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  要设计一个第一人称视角的摄像机，摄像机无非2种操作：平移(玩家位置移动)，旋转(玩家视角变化，比如向左看，像右看…)。我们单纯考虑摄像机的旋转问题(平移比较简单，有兴趣可以看原Po或者看我下面给出的实现)。任何编程问题我们都需要明确我们的输入和输出是什么，那么我们得到的输入是：鼠标在水平和竖直两个方向的平移量，我们需要输出的是：摄像机的朝向，我们用一个从原点出发的三维向量(x,y,z)表示。&lt;/p&gt;

&lt;h3 id=&quot;思考过程&quot;&gt;&lt;strong&gt;思考过程&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;欧拉角&quot;&gt;&lt;strong&gt;欧拉角:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;  我们先介绍欧拉角的概念，欧拉根据旋转轴的不同把旋转分为3种不同的旋转，分别是：类似于点头动作Pitch，和类似以摇头动作的Yaw，以及类似于在地上滚来滚去Roll。
&lt;img src=&quot;/images/eular.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;  结合一下我们玩过的FPS游戏，在&lt;strong&gt;问题描述&lt;/strong&gt;中的输入，鼠标在两个方向的移动分量事实上可以看做是摄像机的Pitch角以及Yaw角。为什么没有Roll角？你特么会在游戏中做&lt;em&gt;歪头&lt;/em&gt;的动作啊？！就连现实也很少做好伐？!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/head.jpg&quot; alt=&quot;pci&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;小学数学&quot;&gt;&lt;strong&gt;小学数学：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;  原文在这里出现了第一个难以理解的地方，原文的配图和描述是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/triangle.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If we define the hypotenuse to be of length 1 we know from trigonometry (soh cah toa) that the adjacant side’s length is cos x/h=cos x/1=cos xcos⁡ x/h=cos⁡ x/1=cos⁡ x and that the opposing side’s length is sin y/h=sin y/1=sin ysin⁡ y/h=sin⁡ y/1=sin⁡ y. This gives us some general formulas for retrieving the length in both the x and y directions, depending on the given angle.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  我看完原文之后的表情和上面尔康是一样的(???)：为毛cosθ=x/h,然后直角边就变成了cosx啊？？？本来很简单的东西一下子就变懵逼了。我认为正确的理解应是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/triangle_fixed.png&quot; alt=&quot;pic&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;二维映射三维&quot;&gt;&lt;strong&gt;二维映射三维：&lt;/strong&gt;&lt;/h4&gt;
</description>
        <pubDate>Thu, 01 Dec 2016 20:16:00 +0800</pubDate>
        <link>http://localhost:4000/2016/12/01/opengl-camera-rotate/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/12/01/opengl-camera-rotate/</guid>
        
        <category>数学</category>
        
        <category>图形学</category>
        
        
        <category>OpenGL</category>
        
      </item>
    
      <item>
        <title>第一篇博客</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#为什么会有这一个博客&quot; id=&quot;markdown-toc-为什么会有这一个博客&quot;&gt;&lt;strong&gt;为什么会有这一个博客?&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#为什么选择在这里搭建&quot; id=&quot;markdown-toc-为什么选择在这里搭建&quot;&gt;&lt;strong&gt;为什么选择在这里搭建&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#怎么在这里搭建&quot; id=&quot;markdown-toc-怎么在这里搭建&quot;&gt;&lt;strong&gt;怎么在这里搭建&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#感谢&quot; id=&quot;markdown-toc-感谢&quot;&gt;感谢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么会有这一个博客&quot;&gt;&lt;strong&gt;为什么会有这一个博客?&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  数了数有接近一年没写博客了，这一年发生了太多事情： 毕业，找工作，升学，分手…还有很多数不清的，麻烦的事情。感觉自己也变了很多，不像以前那样无忧无虑了。以前的同学大多数都去了工作，没有能像以前那样有那么多时间聚在一起玩。现在的同学倒也还不错，大家为了前程都非常努力学习。应了一句歌词 “朋友们都去了远方，我只能每天早上和树说话。” 从前玩得最好的几个同学都开始自给自足了，开始探讨买车买房结婚生子的人生大计。我呢，还在吭老读书，结婚生子的事情似乎比读本科的时候离得更加远了。&lt;/p&gt;

&lt;p&gt;  不过，最近的生活也算是过得稳定而且充实吧～就想着更新一下博客。原来的博客是用worldpress搭建在新浪云SAE上面的，结果前几天登录上去他说我余额不足，然后把我的东西给删了。同时我前几天刚刚重装了系统，之前本地的备份也都没有了…自己的东西没备份好，怪不了其他人(喂谁把SAE给黑了好不好…)。不过这倒让我发现了WorldPress博客的弊端：WorldPress的博客数据是存在他的MySQL数据库里面的，必须要导出成XML才能备份，而且编辑也得用他的编辑器来编辑，格式才不会乱(尽管有插件兼容markdown或者其他语法)。没办法，塞翁失马，就让他失呗。从新开始也是一件好事，毕竟以前的写的博文幼稚又无知。&lt;/p&gt;

&lt;h3 id=&quot;为什么选择在这里搭建&quot;&gt;&lt;strong&gt;为什么选择在这里搭建&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  其实写博客就像是在浩瀚的网络中搭建一个家，出于经常玩Minecraft和饥荒的习惯，对家的选址总是非常谨慎，想了很多地方，注册了很多个账号(比如CSDN，博客园，163博客…)都觉得不太好。于是总结了一下自己对博客的需求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;没有广告&lt;/strong&gt;：一个读者看我的文章还要强制他看广告，是我对他的不尊重。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;免费&lt;/strong&gt;：之前SAE上的费用是一次他故障然后赔我的费用，一直没充值，没想到就这样没了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;能插入代码，数学公式，图片&lt;/strong&gt;：每一个程序员写博客基本上都需要这三样东西吧。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;容易迁移和保存&lt;/strong&gt;：前一次博客的教训。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;简单！简单！简单！&lt;/strong&gt;：只是一个记录思考的地方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  对着上面的要求排除了一下，也就剩下Github Pages和简书这两家了，都试了一下，感觉都不错，尽管简书不能直接的插入数学公式，但是能通过第三方服务器生成图片插入的方法来hack，问题不大。后来还是觉得Github Pages的可定制性高，自己也学过一些Web的知识，所以选择在这安家。&lt;/p&gt;

&lt;p&gt;  说一说Github Pages的优点和缺点吧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;免费，没广告。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;每一次更新博客都是一次commit。&lt;/strong&gt;这对于一个程序员来说是最安心的了。只要Github不倒闭，你的博客就在那，而且支持版本回退。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;博文内容使用markdown格式。&lt;/strong&gt;可以非常轻而易举地插入公式和代码，支持代码高亮，支持在线编辑。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;容易迁移。&lt;/strong&gt;只需要把所有.md文件拷贝下来即可，不涉及数据库啊，服务器啊这些东西。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缺点：
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;搭建麻烦而且坑多。&lt;/strong&gt;我之前以为只要是静态博客生成工具生成的博客都可以使用，后来发现GithubPages只支持jekyll，其他生成工具(比如&lt;a href=&quot;&quot;&gt;pelican&lt;/a&gt;)只能本地生成，然后把html push上去。同时Github在2016年2月升级到了jekyll3，很多教程都是以前的版本，坑有点多。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;强制https访问。&lt;/strong&gt;使用http访问的话会出错。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;怎么在这里搭建&quot;&gt;&lt;strong&gt;怎么在这里搭建&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  我使用的是jekyll+Github Pages，没有为什么，因为Github只支持jekyll。教程网上一搜一大堆，我不在这细说。不过我倒是想说说我遇到的坑(估计是由于我完全不会ruby的缘故，特别是估计我以后都不会用到ruby，也懒得学)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jekyll需要ruby2.0: 在Ubuntu14.04上，需要&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	sudo apt-get install ruby2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  然后&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	sudo gem2.0 install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  才能使用，不然会出错。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入数学公式： 我用的markdown公式是支持mathjax公式编辑的，但是测试jekyll的时候发现不行。解决方法是在博客目录(含有_post/的目录)下的_layout/下的default.html，在head标签中插入一Mathjax提供的JS库。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  当然你也可以把Mathjax的JS库下载下来放到某个子目录然后通过相对路径访问，不过Mathjax太大了，push到Github上面不是很道德，所以我采用的是外链的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码高亮！！！这个弄了我好久。我用到的主题是LessOrMore这个主题，但是他好像在jekyll2.x的时候写的，直接使用放在Github Pages上面显示不出来。主题自带的_config.yaml文件是这样的：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;ss&quot;&gt;highlighter: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rouge&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;# Build settings&lt;/span&gt;
	&lt;span class=&quot;ss&quot;&gt;markdown: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kramdown&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  然后push到Github上面，只能通过jekyll大括号+百分号的方法高亮，不能使用markdown自带的三个backticks的方法，所以写markdown的时候很不爽。我尝试过很多方法。包括更改_config.yaml:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;ss&quot;&gt;markdown: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kramdown&lt;/span&gt;
	&lt;span class=&quot;ss&quot;&gt;highlighter: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rouge&lt;/span&gt;
	&lt;span class=&quot;ss&quot;&gt;kramdown:
		input: &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;GFM&lt;/span&gt;
		&lt;span class=&quot;ss&quot;&gt;syntax_highlighter: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rouge&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  和&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;ss&quot;&gt;pygments: &lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  都不行。其实解决方法就是把关于highlighter和kramdown的几行都删了，因为现在Github只支持kramdown和rouge，所以无需在配置中声明。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Disqus：这个也有教程。关键在于，Disqus会给你一个类似于&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;s1&quot;&gt;'http://'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;disqus_shortname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'.disqus.com/embed.js'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;  的js脚本给你插入，但是Github只支持Https，因此我们需要把所有外链的js脚本(包括之前说的mathjax)都改成https来访问，不然会链接失败。如果你在本地的jekyll使用localhost访问正常，但是到Github Pages上面访问出错，很有可能就是由于使用Http外链js的原因。&lt;/p&gt;

&lt;h3 id=&quot;感谢&quot;&gt;感谢&lt;/h3&gt;
&lt;p&gt;  搭建博客的时候用了很多人的东西，特别感谢。谢谢你们创造出来了这些东西，谢谢你们把这些东西开源。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.github.com&quot;&gt;Github&lt;/a&gt; ——提供的不止是代码托管。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jekyll.com/&quot;&gt;Jekyll&lt;/a&gt; ——优秀的产品(在某种意义上算是)。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruby-lang.org/en/&quot;&gt;Ruby&lt;/a&gt; ——尽管我不太喜欢这种语言，写东西还是喜欢c/cpp or Python or Mathlab，大概因为我老。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/luoyan35714/LessOrMore&quot;&gt;LessOrMore&lt;/a&gt; ——我用到的jekyll主题，但经过仔细修改，感谢作者&lt;a href=&quot;https://github.com/luoyan35714&quot;&gt;luoyan&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 14 Nov 2016 19:23:00 +0800</pubDate>
        <link>http://localhost:4000/2016/11/14/first-post/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/14/first-post/</guid>
        
        <category>感想</category>
        
        <category>环境搭建</category>
        
        
        <category>杂谈</category>
        
      </item>
    
  </channel>
</rss>
