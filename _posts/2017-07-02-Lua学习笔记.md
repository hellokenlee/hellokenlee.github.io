---
layout: post
title:  "Lua学习笔记"
date:   2017-07-02 00:00:00 +0800
categories: 编程
tags: 编程 Lua

---

* content
{:toc}

看《Programming.in.Lua.2th》的读书笔记。因为有python和c/c++基础，读的比较快，仅仅把一些需要注意的地方或者语法糖标注出来。

## 第一章： 开始

1. `lua -i prog.lua`表示执行完prog.lua脚本后直接进入交互模式。
2. 代码中执行`dofile("file.lua")`来动态执行某个文件，可用于加载库。和python的`import`类似。
3. 行注释`--xxxx`， 块注释`--[[xxx]]`。
4. 显式删除一个变量只需要把那个变量赋值为`nil`即可。
5. 定义全局变量`_PROMPT`来更改lua的交互模式提示符；定义系统环境变量`LUA_INT`可编写解释器执行的初始化脚本(使用@文件名 来执行某个文件；直接赋值则当做代码执行。)
6. lua参数存在全局变量`arg`这个table中。按照下标可访问参数的值。
7. 使用`io.read()`从stdin读入数据。
8. lua会默认对数字和字符串类型进行互相转换， 注意性能问题。

## 第二章： 值与类型

1. 复合数据类型table的本质相当于哈希表+数组， 用法相当于python的dict和list的结合。其key可以是任意的值，甚至可以是table本身。比如`a={}; b={}; b[a]=1;`。(**疑问: table是如何用c实现的？**)
2. table变量永远是引用。
3. lua数组下标默认从1开始。
4. `#var`表示求var的长度，当var为字符串时，就是求字符串长度。但当var为table时，所求的是哈希表中第一个为nil的key的下标。因此如果不是满table不建议用`#`求长度，实际长度可以使用`table.maxn(var)`求。
5. lua的字符串永远是常量，不能通过下标修改字符串。因此修改字符串只能新建一个字符串，注意由此带来的性能问题。
6. 使用`[[多行字符串]]`编写多行字符串。

## 第三章： 表达式

1. lua取余定义为：`a%b = a-floor(a/b)*b`因此取余能对负数生效：`-1 % 3 == 2`，也能对小数生效：`3.14 % 1 == 0.14`
2. 使用`..`连接两个字符串
3. table的构造方法，推荐使用`t = {[1] = 1, [2] = 2; ["key1"] = value1, ["key2"] = value2}`写法。

## 第四章： 赋值

1.支持多个变量赋值，用法如python的tuple：`x,y = y,x`。注意如果左右两边的变量数目不一样，那么会把左边多出来的变量设为`nil`或者把右边多出来的值丢弃。
2.需要显式声明局部变量`local i = 1;`，不然都默认为全局变量。(注意交互模式每一行输入都为独立的一个作用域，因此交互模式的local变量在一行输入之后立刻会被销毁。如果需要多行，可以使用`do...end`包围代码块。)
3.对于需要继承全局变量的局部变量， 可以写为`local foo = foo`, 即使用全局变量`foo`去初始化局部变量`foo`， 在这之后该全局变量变为不可见。
4.条件判断写法：
```lua
if ... then
	...
elseif ... then
	...
else
	...
end
```

5 . 使用`repeat ... until(...)`代替`do...while(...)`。注意循环体内的局部变量作用域包括`until()`等条件判断
6 . 数字`for`循环, 表示变量var从a以步长step增加到b执行的语句。（a，b包头包尾，相当于<=b）

```lua
-- 打印1,3,5,7,9
for i = 1, 10, 2 do
	print(var)
end
```

7 . 迭代器for:

```lua
-- 打印table t中的所有key
for it in pairs(t) do
	print(it)
end
```

8 . 注意`retrurn`和`break`只能是一个语法块的最后一句，如果要在中间return， 可以这样写：`do return end`。


## 第五章： 函数

1. 函数支持3种调用方法： `foo(x); o.foo(o, x); o:foo(x);`。 其中`o.foo(o, x)和o:foo(x)`等价。
2. 形参和实参数量不对等的时候遵循 **四.1** 所述规则丢弃或置空。
3. 允许函数返回多个值，如果接收返回值的变量不一样，按照规则丢弃返回值或置空。
4. 使用table构造式完整接收一个函数的所有返回：`t = {foo()}`；假设`foo()`返回数量是运行时确定的也没关系，但只有函数表达式作为最后一个构造元素才有意义。
5. 特殊函数`unpack(t)`，接收一个数组作为参数，返回数组中从下标为1开始的所有元素。
6. 变长参数`foo(...)`，使用表达式`t = {...}`获取所有参数。
7. 使用函数`select(i, ...)`获取变长中第i个参数；`select('#', ...)`获取参数的数量。
8. 可以通过传入一个table来实现类似python的带名字参数的函数调用。如：`os.rename({old = "temp.txt", new = "temp.txt.bk"})`。
9. 

附：变长add函数实现：
```lua
function add(...)
	local s = 0
	for i, v in ipairs({...}) do
		s = s + v
	end
	return s
end
```


附：unpack()函数的实现原理：

```lua
function unpack(t, i):
	i = i or 1
	if t[i] then
		return t[i], unpack(t, i + 1)
	end
end
```